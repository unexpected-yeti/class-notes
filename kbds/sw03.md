# Semantic Web Languages & Wissensgraphen (SW03)

_Knowledge Representation Formalisms_ (siehe SW02) dienen prim√§r der Repr√§sentation von Wissen f√ºr **kleine, abgeschlossene Anwendungsf√§lle**. Die Gr√ºnde liegen in der **mangelhaften Skalierbarkeit** im Einsatz sowie im **fehlenden Standardvokabular**.

Hier kommen die _Semantic Web Languages_ ins Spiel. Sie besch√§ftigen sich mit der **Wissensrepr√§sentation in offenen und prim√§r grossen Systemen**, wie z.B. dem Internet.
Dabei wird das Ziel verfolgt, das Web f√ºr Maschinen interpretierbar zu machen.
Um die Probleme der _Knowledge Representation Formalisms_ zu umgehen wurden Repr√§sentationsstandards sowie ein Standardvokabular eingef√ºhrt.
Diese Standards werden von der [W3C](https://w3.org) verwaltet und umfassen:

- RDF (Resource Description Framework)
- RDFS (RDF Schema)
- OWL (Web Ontology Language)

## RDF (Resource Description Framework)

üéØ **Lernziel**: Sie kennen die Einsatzm√∂glichkeiten von RDF, RDFS und OWL, sowie deren Unterschiede.

Das _RDF_ wurde 1999 durch das W3C eingef√ºhrt, um Webinhalte systematisch zu modellieren.
Als Webinhalte z√§hlen _Webseiten_, _Dokumente_, _Bilder_ und weitere Quellen.

_RDF_ setzt sich aus den folgenden Komponenten zusammen:

- **Resource**: Eine Ressource ist eine relevante Entit√§t, die per URI (_uniform resource identifier_) in das zu modellierende System aufgenommen wird. Eine URI bezeichnet ein identifizierbares Merkmal, nicht zwingend eine URL.
- **Description**: Hiermit wird die Beziehung zwischen Ressourcen charakterisiert. Dazu wird entweder ein _Property Type_ oder _Value_ verwendet. Die Verkn√ºpfung wird mit _URIrefs_ hergestellt.
- **Framework**: Als _Framework_ bezeichnet man das standardisierte Vokabular zur Modellierung des Sachverhalts.

> Das Dataset [linked open vocabularies](https://lov.linkeddata.es/dataset/lov) kann nach standardisierten Beziehungs-Bezeichnern durchsucht werden.

![Aufbau eines RDF Statements](assets/kbds_rdf-statement.png)

### Modellierung mit Graphen

Als Werkzeug zur Modellierung des Sachverhalts dienen bei _RDF_ Graphen.
Diese Graphen bestehen aus _Triples_:

1. **Subjekt**: Dies ist die Entit√§t, die charakterisiert werden soll (Knoten).
2. **Objekt**: Das Objekt ist ein Wert (z.B. eine Webseite, ein Name, eine E-Mail-Adresse etc.) (Knoten)
3. **Pr√§dikat**: Das _Pr√§dikat_ bezeichnet die Beziehungsart zwischen _Subjekt_ und _Objekt_.

**Beispiel**:

![Beispiel RDF-Graph](assets/kbds_rdf-graph-example.png)

Geh√∂ren verschiedene Sachverhalte zusammen, haben aber keine Entit√§t, so werden _blank nodes_ eingesetzt.

![Beispiel Blank Nodes](assets/kbds_rdf-blank-nodes.png)

### Web Of Data

Ein Subjekt ist immer identifizierbar per URI.
Verschiedene _Triples_ bzw. _RDF-Graphen_ desselben Subjekts k√∂nnen so gesammelt und kombiniert werden.
Inhalte k√∂nnen so miteinander verkn√ºpft werden.
Dem entstehenden Netz sagt man _Web of Data_.
Dieses _Web of Data_ erm√∂glicht Maschinen die Extraktion des Kontexts aus der Unmenge an Daten aus verschiedensten Quellen des Internets.
Das zentrale Bindeglied dabei ist die standardisierte Repr√§sentationssprache.

## RDFS (RDF Schema)

üéØ **Lernziel**: Sie kennen die Einsatzm√∂glichkeiten von RDF, RDFS und OWL, sowie deren Unterschiede.

Bei _RDF_ ist nach wie vor ein grosser Interpretationsspielraum f√ºr die verschiedenen Bezeichner der Entit√§tsbeziehungen vorhanden.
Die W3C adressierte dieses Problem im Jahre 2000 durch die semantische Erweiterung des RDF-Datenmodells mit einem Schema.
Das _Schema_ dient der taxonomischen Strukturierung von _Resources_ und kann die kontextuellen Abh√§ngigkeiten unter Ressourcen genauer spezifizieren.

Beispiele daf√ºr sind _class_, _property_, _type_, _subClassOf_, _subPropertyOf_, _range_, _domain_.

_RDFS_ wird auch als _Lightweight Ontology Language_ bezeichnet.

> Der Zusammenhang von RDF und RDFS ist vergleichbar mit jenem von _Semantic Networks_ und _TBox, ABox_ aus der vorhergehenden Semesterwoche.

### Komponenten

Das RDF Schema legt die Komponenten _Resource_, _Class_ und _Property_ fest.
Alle Ressourcen sind implizit Instanzen von `rdfs:Resource`.

#### Klassen

Eine Klasse beschreibt ein Set von Ressourcen. Eine Klasse selber ist wiederum eine Ressource und ist implizit Teil von `rdfs:Class`.
Hierarchische Verbindungen werden durch `rdfs:subClassOf` erm√∂glicht.

| Attribut        | Beschreibung                    |
| --------------- | ------------------------------- |
| `rdfs:Resource` | Klasse aller Ressourcen         |
| `rdfs:Class`    | Klasse aller Klassen            |
| `rdfs:Literal`  | Klasse aller Literals (strings) |
| `rdfs:Property` | Klasse aller Properties         |
| `rdfs:Datatype` | Klasse aller Datentypen         |

#### Properties

Die Properties bilden ein Subset der RDFS Ressourcen mit den folgenden Eigenschaften:

- **Domain**: Dies ist eine Klasse des Typs `rdfs:domain` mit einer Property (Eigenschaft)
- **Range**: Dies ist ein Wert, der mit der Klasse assoziiert wird. Daf√ºr wird `rdfs:range` verwendet.

| Attribut             | Beschreibung                                                                                   |
| -------------------- | ---------------------------------------------------------------------------------------------- |
| `rdfs:subClassOf`    | Legt die Klassenhierarchie fest, verbindet Sub- mit Superklassen, ist per Definition transitiv |
| `rdfs:subPropertyOf` | Verbindet Sub- mit Superproperties, ist per Definition transitiv                               |
| `rdfs:domain`        | Legt die Klasse des Subjekts im Triple fest                                                    |
| `rdfs:range`         | Legt die Klasse oder den Datentyp des Objekts eines Triples fest                               |
| `rdfs:comment`       | Stellt typischerweise eine l√§ngere textuelle Beschreibung einer Ressource dar                  |
| `rdfs:label`         | Assoziiert die Ressource mit einem _human-readable_ Namen                                      |
| `rdfs:isDefinedBy`   | Referenziert auf die Definition einer Ressource, typischerweise ein RDF Schema                 |
| `rdfs:seeAlso`       | Verlinkt eine Ressource mit einer weiterf√ºhrenden, erkl√§renden Ressource                       |

### Beispiel

Das untenstehende Beispiel soll den vorhergehend beschriebenen Sachverhalt veranschaulichen.

![Beispiel RDFS Alex lebt in Fribourg](assets/kbds_rdfs-example.png)

### Schwachstellen

W√§hrend _RDFS_ einige Probleme l√∂st, mit denen sich _basic RDF_ konfrontiert sah, so weist es doch einige Schwachstellen auf.

- **Eindeutigkeit**: Das Vokabular ist zu schwach f√ºr die zweifelsfreie Modellierung von Sachverhalten.
- **Quantifizierbarkeit**: Quantifizierbare Bedingugnen k√∂nnen nicht modelleirt werden (z.B. maximale St√ºckzahl ist 2).
- **Automatisierbares Reasoning**: Eine automatisierte Entscheidungsfindung ist nur bedingt m√∂glich, denn gewisse Elemente der Formulierung k√∂nnen frei beschrieben werden.

_RDFS_ ist also auch nicht aller Probleme L√∂sung.

## OWL (Web Ontology Language)

üéØ **Lernziel**: Sie kennen die Einsatzm√∂glichkeiten von RDF, RDFS und OWL, sowie deren Unterschiede.

Aufgrund der bei _RDFS_ erkl√§rten Schwachstellen wurde ein weiterer aufbauender Standard entwickelt: Die Web Ontology Language (kurz: OWL).

> Der aufmerksame Leser mag sich an dieser Stelle fragen, ob dem Autor ein Schreibfehler unterloffen ist (womit die Spannung wom√∂glich um einiges angestiegen ist).
> Tats√§chlich ist dies nicht der Fall! Die Ursache des Nicht-Akronyms kann [im deutschen Wikipedia-Artikel](https://de.wikipedia.org/wiki/Web_Ontology_Language#Abk%C3%BCrzung) nachgelesen werden.

Von den durch RDFS offengelassenen Schwachstellen soll mit _OWL_ vor allem das **automatische Reasoning** erm√∂glicht werden.
Dazu wurden drei verschiedene Versionen von OWL eingef√ºhrt:

1. **OWL Full**: Diese Version nutzt die OWL-Syntax sowie RDF.
2. **OWL DL**: Bei dieser Version wird _Description Logic_ (vgl. SW02, mit _ABox_, _TBox_ etc.) verwendet.
3. **OWL Lite**: Hierbei handelt es sich um eine vereinfachte Version vom oben beschriebenen _OWL DL_.

Der Einsatz von Description Logic bringt einige Vorteile mit sich: Die Semantik ist klarer definiert.
Es existieren bereits _Reasoning Algorithmen_, die auf Description Logic aufbauen.
Im Bereich der Description Logic wurden bereits viel Forschung betrieben und Erfahrungen im Einsatz gesammelt.

Dies eliminiert die im Kapitel _RDFS_ beschriebenen Schwachstellen.

### Operatoren

In OWL gibt es integrierte Operatoren, √ºber welche die untenstehende Tabelle Aufschluss geben soll.
Die Operatoren werden in XML (bzw. HTML) als _nodes_ dargestellt.

| Operator              | Beschreibung                                                                                                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `owl:unionOf`         | Die Klasse enth√§lt Elemente, die aus mehr als einer anderen Klasse stammen ([Mengenlehre](<https://en.wikipedia.org/wiki/Union_(set_theory)>).                                        |
| `owl:disjointWith`    | Zwei Klassen geh√∂ren _disjunkten_ Mengen an bzw. geh√∂ren nicht zusammen (z.B. verschiedene Geschlechter, [Mengenlehre]https://en.wikipedia.org/wiki/Disjoint_sets))                   |
| `owl:intersectionOf`  | Die Elemente geh√∂ren auch zu einere anderen Klasse ([Mengenlehre]https://en.wikipedia.org/wiki/Intersection_(set_theory))).                                                           |
| `owl:equivalentClass` | Dieser Operator beschreibt Synonyme.                                                                                                                                                  |
| `owl:complementOf`    | Die Klasse enth√§lt Elemente, die nicht Teil einer anderen Klasse sind (z.B. Kinder geh√∂ren nicht zu Senioren, [Mengenlehre](<https://en.wikipedia.org/wiki/Complement_(set_theory)>)) |

#### Beispiel

So kann beispielsweise eine Wohnung mithilfe des Operators `owl:unionOf` wie folgt beschrieben werden:

```xml
<owl:Class rdf:ID="Wohnung">
    <rdfs:subClassOf>
        <owl:Class rdf:about="#Bestandteile"/>
    </rdfs:subClassOf>
        <owl:equivalentClass>
        <owl:Class>
            <owl:unionOf rdf:parseType="Zusammensetzung">
            <owl:Class rdf:about="#Schlafzimmer"/>
            <owl:Class rdf:about="#K√ºche"/>
            <owl:Class rdf:about="#Bad"/>
            <owl:Class rdf:about="#Wohnbereich"/>
            </owl:unionOf>
        </owl:Class>
    </owl:equivalentClass>
</owl:Class>
```

### Attribute

Mithilfe von XML-/HTML-Attributen k√∂nnen noch pr√§zisere Aussagen formuliert werden.

|       Attribut       |                     Beschreibung                      |
| -------------------- | ----------------------------------------------------- |
| `owl:hasValue`       | Definiert die Auswahl an spezifischen Werten (Values) |
| `owl:someValuesFrom` | Mind. 1 Wert stammt von einer Klasse                  |
| `owl:allValuesFrom`  | Alle Werte die einer Klasse angeh√∂ren.                |
| `owl:minCardinality` | Mindestwert                                           |
| `owl:maxCardinality` | H√∂chstwert                                            |
| `owl:Cardinality`    | Genauer Zahlenwert                                    |

#### Beispiel

Somit kann nun quantifiziert werden. 
Eine Wohnung kann somit mit genau einem Badezimmer gekennzeichnet werden.

```xml
<owl:Class rdf:ID="Wohnung">
    <rdfs:subClassOf rdf:resource="#Bad" />
        <owl:subClassOf>
            <owl:Restriction owl:cardinality="1">
            </owl:Restriction>
        </owl:subClassOf>
    </rdfs:subClassOf>
</owl:class>
```

## Wissensgraphen (knowledge graphs)

üéØ **Lernziel**: Die Einsatzm√∂glichkeiten und Vorteile von Knowledge Graphs sind ihnen gel√§ufig.

Die semantsiche Modellierung des Internets war wohl etwas schwierig mit den bisher vorgstellten Methoden zur Wissensrepr√§sentation.
Deswegen f√ºhrte Google 2012 die _knowledge graphs_ ein.

> A knowledge graph is a special kind of database which stores knowledge in a machine-readable form and provides a means for information to be collected, organised, shared, searched and utilised. ([DBpedia](https://wiki.dbpedia.org/about))

Suchabfragen k√∂nnen damit auch kontextbezogene Fragestellungen beantworten, ohne auf das Matching von Suchanfragetext und Dokumentinhalt reduziert zu sein (PageRank).
Der bestehende Knowledge Graph enth√§lt eine F√ºlle unterschiedlicher Daten (z.B. Personen, Definitionen, Orte).
Diese Daten stammen aus zahlreichen Quellen. Die wichtigsten davon sind Online-Enzyklop√§dien wie [Wikipedia](https://wikipedia.org).

Quellen wie Wikipedia bieten folgende Vorteile. Die Konzepte sind manuell definiert.
Die Zusammenh√§nge sind definiert. Es besteht eine Repr√§sentationssprache.
Es ist eine grosse Menge an breit gestreutem Wissen gesammelt, die kontinuierlich aktualisiert wird.
Und nat√ºrlich die Kosten - diese Daten sind verf√ºgbar.
 
 ### DBpedia

 Das _crowd-sourced_ Projekt [DBpedia](https://wiki.dbpedia.org/about) hat es sich zur Aufgabe gemacht, strukturierten Inhalt aus verschiedenen Wikimedia-Projekten zu extrahieren.
 Diese strukturierte Informationssammlung √§hnelt einem _open knowledge graph (OGK)_, der f√ºr jeden im Web verf√ºgbar ist.

 ### Anwendungsbereiche

- **Semantische Suchmaschinen**
- **Social Media (Social Graph)**: Benutzerempfehlungen, Produkt Empfehlungen, etc.
- **Telekommunikation (Network Graph)**: Netzwerk Abh√§ngigkeiten, Auslastungsgrade, etc.
- **Online Bezahldienste (Payment Graph)**: Betrugspr√§vention, Risikoevaluation, etc.
- **Banken (Portfolio Graph)**: Budgetplanung, Trading, Compliance, etc.
- **Medizin (Health Graph)**: Medikament Entwicklung, Genetik, Arztempfehlung, etc.
- **Terrorismus und Verbrechensbek√§mpfung**

#### Semantische Suchmaschinen

 In semantischen Suchmaschinen werden Wissensgraphen verwendet. Das wohl prominenteste Beispiel hierf√ºr ist Google Hummingbird.
 Bei der semantischen Suche werden die in der Suchanfrage verwendeten W√∂rter miteinander in Verbindung gebracht, um die Bedeutung der Anfrage in den Mittelpunkt zu stellen.
 Anders als bei _keyword-based_ Suchalgorithmen kann so die Bedeutung der einer Frage ermittelt werden, ohne zwingend bestimmte W√∂rter enthalten zu m√ºssen.

 ![Beispiel Google Suchergebnis mit Hummingbird-Algorithmus](assets/kbds_hummingbird-example.png)