# KRYPTO - SW 1 & 2

ğŸ¯ Ich kann die Grundbegriffe der Kryptologie richtig einordnen.
ğŸ¯ Ich kann den Nutzen von kryptographischen Massnahmen beurteilen. 
ğŸ¯ Ich kann die verschiedenen Schutzmechanismen unterscheiden.
ğŸ¯ Ich kann die 8 typischen Angriffe, die mit Hilfe der Kryptographie verhindert werden kÃ¶nnen, aufzÃ¤hlen.
ğŸ¯ Ich kann die Zuordnung, mit welchen Schutzmechanismen welche Angriffe verhindert werden kÃ¶nnen, anwenden. 
ğŸ¯ Ich kann bei einem kryptographischen System erkennen, welches der SchlÃ¼ssel und welches das Verfahren (Algorithmus) ist.
ğŸ¯ Ich kenne den Unterschied zwischen symmetrischer und asymmetrischer Kryptographie.
ğŸ¯ Ich kenne den Unterschied zwischen VerschlÃ¼sseln und IntegritÃ¤tsschutz.
ğŸ¯ Ich kenne den Unterschied zwischen einer digitalen Signatur und einem MAC.
ğŸ¯ Ich kann die StÃ¤rke eines Passwortes in die LÃ¤nge eines kryptographischen SchlÃ¼ssels umrechnen.



## Kryptopuzzle



| Vertraulichkeit                                 | IntegritÃ¤t / AuthentizitÃ¤t               |
| ----------------------------------------------- | ---------------------------------------- |
| Mechanismus: VerschlÃ¼sselung<br />Geheimhaltung | Mechanismus: "Authentizierwert" anhÃ¤ngen |

![image-20210105124211059](assets/assets/image-20210105124211059.png)



# Angriffe im klassischen Kryptomodell

![image-20210105125106373](assets/assets/image-20210105125106373.png)



Die drei Parteien kÃ¶nnen unterschiedliche Angriffe ausfÃ¼hren

**Sender (Alice)**

* Abstreiten, dass sie die Meldung geschickt hat (*Non repudiation of origin*, "Unleugbarkeit des Ursprungs")
* Eine Meldung nochmals schicken (Replay)
* Sich fÃ¼r jemanden anders ausgeben (Masquerade) (=> In diesem Fall wÃ¤re Alice in der Rolle von Eve)



**Eavesdropper (Eve)**

* AbhÃ¶ren einer Meldung / EntschlÃ¼sselung (Verletzt Confidentiality)
* Meldung verÃ¤ndern (Verletzt IntegritÃ¤t)
* Erfundene Meldung einspielen (Insertion Attacke)
* Meldung abfangen und spÃ¤ter wieder einspielen (Replay Attacke)
* LÃ¶schen einer Meldung (Delete)
* Sich fÃ¼r jemanden anders (zB fÃ¼r Alice) ausgeben (Masquerade Attack)

**Recipient (Bob)**

* Abstreiten die Meldung erhalten zu haben (*Non repudiation of receipt*)



## Akive vs. passive Angriffe

* Passiv: Unternimmt alles, um eine Nachricht abzuhÃ¶ren. Greift jedoch nicht aktiv in die Kommunikation ein (z.B. durch VerfÃ¤lschen einer Nachricht)
* Aktiv: Greift bewusst in die Kommunikation ein, z.B. verfÃ¤lscht eine Nachricht oder spielt eine erfundene Meldung ein.



## SchlÃ¼sselasutausch

* Symmetrisch (*Fall: Jeder mit jedem*): Es benÃ¶tigt in einem Kommunikationssystem mit $n$ Teilnehmer $n(n-1) / 2$ respektive $n(n-1)$ SchlÃ¼ssel
* Assymetrisch (*Fall: Jeder mit jedem*): Es benÃ¶tigt $n$ SchlÃ¼sselpaare (jeder Teilnehmer macht seinen Ã¶ffentlichen SchlÃ¼ssel zugÃ¤nglich)



Es gibt auch AnwendungsfÃ¤lle in symmetrischer Krypto, in welcher nur $n$ SchlÃ¼ssel benÃ¶tigt werden - beispielsweise in einer Sterntopologie:

![image-20210105131707411](assets/assets/image-20210105131707411.png)

Da die Teilnehmer nur mit dem zentralen Host kommunizieren, benÃ¶tigt es nur $n$ symmetrische SchlÃ¼ssel die der zentrale Host kennt.



Es ist mÃ¶glich, dass bei symmetrischen Verfahren fÃ¼r beide Richtungen der Kommunikation ($A \rightarrow B$ sowie $B \rightarrow A$) derselbe SchlÃ¼ssel verwendet wird. In der Regel sind dies jedoch unterschiedliche SchlÃ¼ssel. Bei der asymmetrischen Krypto sind diese unterschiedlichen SchlÃ¼ssel inherent gegeben.

Pro *Dienst* (wie VerschlÃ¼sselung, IntegritÃ¤tsschutz etc) werden verschiedene SchlÃ¼ssel verwendet. Somit ist es nicht erlaubt, mit demselben SchlÃ¼sselpaar zu VerschlÃ¼sseln sowie zu Signieren.

<hr />

**Aufgabe 4.4**: 1000 Computer sollen so vernetzt werden, dass jeder mit jedem einen separaten SchlÃ¼ssel hat.

Symmetrischer Fall:

Gegeben: Nur ein Dienst (e.g. Encrypt) und beide Wege denselben Key benÃ¶tigen:

Anzahl Teilnehmer $n = 1000$, somit $n ( n - 1) / 2 = 1000 (1000 - 1) / 2= 1000 * 999 / 2= 999'000 / 2 = 499.500 \text{ Keys}$



Gegeben: Gegeben: Nur ein Dienst (e.g. Encrypt) und beide Wege unterschiedliche Keys benÃ¶tigen:

Anzahl Teilnehmer $n = 1000$, somit $n ( n - 1) = 1000 (1000 - 1) = 1000 * 999= 999'000 \text{ Keys}$



Gegeben: Gegeben: Zwei Dienste (e.g. Encrypt, Sign) und beide Wege unterschiedliche Keys benÃ¶tigen:

$2 * n (n-1) = 999'000 * 2 = 1'998'000 \text{ Keys}$

Assymetrischer Fall:

Gegeben: Nur ein Dienst (e.g. Encrypt) und beide Wege denselben Key benÃ¶tigen:

$n = 1000 \text{ key pairs}$ -> Der Fall, dass beide denselben Key verwendet, ist gar nicht mÃ¶glich!

Gegeben: Nur ein Dienst (e.g. Encrypt) und beide Wege unterschiedliche Keys benÃ¶tigen:

$n = 1000 \text{ key pairs}$

Gegeben: Gegeben: Zwei Dienste (e.g. Encrypt, Sign) und beide Wege unterschiedliche Keys benÃ¶tigen:

$2n = 2000 \text{ key pairs}$



## Passwort- & SchlÃ¼sselgrÃ¶ssen

Codierungen, Anzahl Bit pro Zeichen

| what                            | Anzahl mÃ¶gliche Zeichen | Bits pro Zeichen                                    |      |
| ------------------------------- | ----------------------- | --------------------------------------------------- | ---- |
| Digits (0..9)                   | 10                      | $2^x = 10 = ln(10) / ln(2) = 3.32$ Bits pro Zeichen |      |
| Hexadecimal (0..F)              | 16                      | $2^x = 16 = 4$ Bits pro Zeichen                     |      |
| Alphabet (A..Z)                 | 26                      | $2^x = 26 = 4.7$ Bits pro Zeichen (in Folien: 4.46) |      |
| Alphabet + Digits (A..Z, 0..9)  | 36                      | 5.16 Bits pro Zeichen                               |      |
| Base64 (A..Z, a..z, 0..9, /, +) | 26 + 26 + 10 + 2        | 6                                                   |      |

Die Anzahl der Bits pro Zeichen ergibt sich aus der LÃ¶sung der Gleichung (fÃ¼r $x$):
$$
2^x = \text{Anzahl mÃ¶glicher Zeichen}
$$
E.g. bei 10 Zeichen:
$$
2^x = 10 \rightarrow \frac{ln(10)}{ln(2)} = 3.32 
$$
Somit ergibt sich 3.32 Bits pro Zeichen. Um nun daraus einen 128 Bit SchlÃ¼ssel zu konstruieren, bentÃ¶tigt es:
$$
\frac{128}{3.32} = 38.55 = 39 \text{ Zeichen}
$$
Beispiele:

`39475 10485 98021 43380 05872 49759 70291 2634 ` =  39 Digits = 39 Digits * 3.32 Bits pro Zeichen = 129.48 Bits

`3F8A 84D1 EA7B 5092 C64F 8EA6 73BD F01B` = 32 Hex Chars * 4 Bits pro Zeichen = 128

`AWORH GHJBP IUCMX MLZFQ TZDOP ZJV` = 28 * 4.64 = 129.92 Bits

`E5RGL UPQ7A 8F3ZP NWTIC 22JBM` = 25 * 5.16 = 129 Bits

`y5GNa Riq92 VCm4Q 1BOKl x0` (Base 64) = 22 * 6 = 132 Bits





5.1: 

a) StÃ¤rke einer 6-stelligen PIN (Assume: Numeric PIN): 6 Digits * 3.32 = 19.92 Bits = 20 Bits

b) `EB832A10B5A8221D6E7E` (hex): 20 * $ln(16) / ln(2)$ = 80 Bits

c) Schreiben Sie ein Passwort hin das eine kryptografische StÃ¤rke von ca. 120 Bits besitzt und erklÃ¤ren Sie kurz wie Sie es gebildet haben:

Idee: Hex Passwort da 4 Bytes (einfacher): Dazu braucht es (120 / 4) = 30 Zeichen

`0123456789ABCDEF0123456789ABCD`

d) Welche kryptographische StÃ¤rke in Bit hat in etwa folgendes, in AnfÃ¼hrungszeichen gesetztes Passwort bestehend aus 20 Base64 Zeichen: â€6+R2z7BOQ4GW5TJxhF14â€œ

Base64 => 64 MÃ¶gliche Zeichen, 6 Bits pro Zeichen. 20 * 6 = 120 Bits.



# Hashfunktionen

![image-20210105142610688](assets/assets/image-20210105142610688.png)

**Anwendung:** Hashfunktion(Dokument / Meldung) = Message Digest (MD), Hash oder Fingerprint



Eine Hashfunktion ist eine Einwegfunktion und produziert aus einer Meldung mit variabler LÃ¤nge einen Hash von fixer GrÃ¶sse (z.B. 256 Bits).





# Sicherheitsanforderungen

2 Anforderungen & 2 Schutzmechanismen => 2 * 2 = 4 Prinzipien

| Vertraulichkeit / Geheimhaltung | AuthentizitÃ¤t / IntegritÃ¤t                                   |      |      |
| ------------------------------- | ------------------------------------------------------------ | ---- | ---- |
| VerschlÃ¼sselung                 | "Authentizierwert anhÃ¤ngen"                                  |      |      |
| Symmetrisch: Verhindert abhÃ¶ren | Symmetrisch (MAC, hashfunktion mit Key): Verhindert Insertion Attacke, gewÃ¤hrt IntegritÃ¤t |      |      |
| Asymetrisch: Verhindert abhÃ¶ren | Asymmetrisch (Digitale Signatur): IntegritÃ¤t, Insertion, Non. Rep. of Origin |      |      |



# Symmetrisch vs. Asymmetrisch

Symmetrisch:

* Schnelle Berechnung fÃ¼r grosse Datenmengen
* Problem: Sichere SchlÃ¼sselverteilung

Asymmetrisch:

* Einfaches Key Management
* Problem: Ca. 1000-mal langsamer als symmetrische Verfahren

Hybrid:

* Daten werden symmetrisch verschlÃ¼sselt (e.g. mit einem Session Key, zufÃ¤llig)
* Der Key wird asymmetrisch Ã¼bergeben, indem der symmetrische SchlÃ¼ssel in einem asymmetrischen Verfahren mitgeschickt wird.
* Vorteile beider Welten: Einfaches Key Mgmt und bessere Performance bei der VerschlÃ¼sselung

Angriffe respektive Eigenschaften von Hashfunktionen:

1. Pre-Image Resistance: Gegeben $H(m)$, sollte es schwierig sein um auf $m$ zu schliessen
2. Second Pre-Image Resistance: Gegeben $m_1$ sollte es schwierig sein ein $m_2$ zu finden sodass $H(m_1) = H(m_2)$ gilt.
3. Collision Resistance: Es sollte schwierig sein, zwei $m$ ($m_1, m_2$) zu finden sodass  $H(m_1) = H(m_2)$ gilt.

Unterschied #2 und #3: Die Second Pre-Image Resistance geht davon aus, dass $m_1$ eine bestimmte Meldung sein muss und somit einen bestimmten (**bekannten**) Hash ergibt (z.B. ein Passwort finden, dass denselben bekannten Hash ergibt). Die Collision Resistance wÃ¤hlt dabei zufÃ¤llige Meldungen $m$ die denselben Hash ergben.



# Fazit

![image-20210105144304498](assets/assets/image-20210105144304498.png)

![image-20210105144321225](assets/assets/image-20210105144321225.png)

# Varia

* klassisches modell vs "embedded security" modell: -> krypto betrachtet nur das klassische modell



## Sicherheitsanforderungen

CIA:

* Confidentiality / Vertraulichkeit
* Integrity (IntegritÃ¤t)
* Availability (VerfÃ¼gbarkeit)

Weitere:

* Verbindlichkeit
* AuthentizitÃ¤t
* Non Repudiation



Krypto kann Vertraulichkeit & IntegritÃ¤t / AuthentizitÃ¤t gewÃ¤hren



## Gegner & Angriffe

**Unintelligente Angriffe / Gegner**

* Fehler & StÃ¶rungen (Rauschen auf Leitungen, Stromausfall, Naturereignisse, Software- oder Hardwarefehler, User Error etc)

**Intelligente Angriffe / Gegner**

* Versuchen aktiv / bewusst ein System an der schwÃ¤chsten Stelle anzugreifen (Hackern bis zu Geheimdiensten)
* KRYPTO beschÃ¤ftigt sich mit dieser Art

